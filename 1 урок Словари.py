#Словарь (dictionary) - это тип данных,
#представляющий собой неупорядоченный набор пар ключ:значение.
# (при этом каждый ключ, в рамках одного словаря, является уникальным).
#typedef struct {
#    Py_hash_t me_hash;
#    PyObject *me_key;
#    PyObject *me_value;
#} PyDictKeyEntry;

#Здесь:

#me_hash — кэшированный хеш-код me_key;
#*me_key — указатель на объект, содержащий ключ элемента;
#*me_value — указатель на объект, содержащий значение элемента.

#Теперь перейдем к облику самой C-структуры словаря в Python:

#typedef struct {
#    PyObject_HEAD
#    Py_ssize_t ma_used;
#    uint64_t ma_version_tag;
#    PyDictKeysObject *ma_keys;
#    PyObject **ma_values;
#} PyDictObject;

#PyObject_HEAD — заголовок;
#Py_ssize_t ma_used — количество элементов словаря;
#uint64_t ma_version_tag — уникальная версия словаря, меняющаяся каждый раз при его обновлении;
#PyDictKeysObject *ma_keys — указатель на массив ключей;
#PyObject **ma_values — массив указателей на значения ключей.
#Если ma_values IS NULL, то все пары ключ:значение содержатся в ma_keys.



#Базовая работа со словарями
#Объявление словаря

example_dict = {}
print(type(example_dict))
example_dict_2 = {'keyOne': 'valueFirst', 'keyTwo': 'valueSecond', 'keyThree': 'valueThird'}
example_dict_2['keyThree']



#Помимо литерального объявления, в Python существует возможность объявлять словари при помощи функции dict():
inventory_dict = dict(right_hand='sword', left_hand='shield')
inventory_dict



#Вариант №1.
#Если вам необходим словарь, каждому ключу которого сопоставлено одно и то же значение,
# то можно воспользоваться методом fromkeys():

# словарь из десяти элементов со значениями, равными 0
zero_array_dict = dict.fromkeys(['a0', 'b0', 'c0', 'd0'], 0)
zero_array_dict



#Вариант №2.
#С помощью функции-упаковщика zip(), вызванной внутри dict(),
#вы можете составить словарь из двух списков (в случае несовпадения длин списков, функция самостоятельно отсечет лишние элементы):

key_list = ['marvel_hero', 'dc_hero']
value_list = ['Spiderman', 'Flash']
superhero_dict = dict(zip(key_list, value_list))
superhero_dict
print((superhero_dict))





#Обращение к элементу словаря в Python
#Извлечь значение элемента словаря можно единственным образом — обратившись к нему по его ключу:
hero_inventory = dict(strong_right_hand='sword', strong_left_hand='shield +3')
what_in_right_hand = hero_inventory['strong_right_hand']
# или так: what_in_right_hand = hero_inventory.get('strong_right_hand')
print(what_in_right_hand)


#В отличие от списков, номеров позиций в словарях нет
#Добавление нового элемента в словарь
superhero_dict = {'dc_hero': 'Flash'}

superhero_dict['dark_horse_hero'] = 'Hellboy'
print(superhero_dict)
#Аналогичным образом можно произвести замену существующего значения по его ключу:
superhero_dict['dc_hero'] = 'Batwoman'
print(superhero_dict)



#Удаление элемента из словаря
#Для того чтобы удалить запись в словаре воспользуемся оператором del:
# запись “'dark_horse_hero': 'Hellboy'” исчезнет. Прости, Красный!
del superhero_dict['dark_horse_hero']
print(superhero_dict)

#Проверка на наличие ключа в словаре Python
#Как отмечалось выше, обращение по несуществующему ключу вызывает ошибку в работе интерпретатора.
#Поэтому, наличие ключа в словаре следует проверять. За это дело отвечает оператор in:
if 'marvel_hero' in superhero_dict:
    print ("Да, такой ключ есть")
else:
    print("Этот ключ в словаре отсутствует!")


#Длина словаря в Python
#Стоит помнить, что словарь — это лишь набор отображений, а не последовательность,
#однако количество записей в нём мы все еще можем получить, воспользовавшись функцией len():
treasure = dict(t1='gold', t2='necklace')
num_of_items = len(treasure)
print(num_of_items)




#Сортировка словаря
#Сортировка по ключу
#Сортировка по ключам выполняется с использованием функции sorted(). Работает функция так:
statistic_dict = {'b': 13, 'd': 30, 'e': -32, 'c': 93, 'a': 33}
for key in sorted(statistic_dict):
    print(key)


#Сортировка по значению
#А вот — один из вариантов сортировки словаря по значениям:
elements = {'el1': 1, 'el2': 0, 'el3': -2, 'el4': 95, 'el5': 13}
for key, val in sorted(elements.items(), key= lambda x: x[1]):
    print(val)
#Здесь стоит учитывать, что, сама по себе, запись sorted(elements.items(), key= lambda x: x[1]) 
#будет возвращать не словарь, а отсортированный список кортежей. Поэтому более правильным вариантом будет:
elements = {'el1': 1, 'el2': 0, 'el3': -2, 'el4': 95, 'el5': 13}
elements_sorted = {k: elements[k] for k in sorted(elements, key=elements.get, reverse=True)}
print(elements_sorted)






#Перебор словаря в Python
#Не является великой тайной и тот факт, что словарь, являющийся, по сути своей,
#набором пар (т.е. коллекцией), можно всячески итерировать. Один из способов — перебор по ключам:
iter_dict = {'key_b': 1, 'key_d': 0, 'key_e': -2, 'key_c': 95, 'key_a': 13}
for key in iter_dict:
    print(key, end=' ')

#Другой способ — проитерировать с использованием метода .items().
#В этом случае на каждой итерации, пара ключ:значение будет возвращаться к нам в виде кортежа (‘ключ’, значение):
iter_dict = {'key_b': 1, 'key_d': 0, 'key_e': -2, 'key_c': 95, 'key_a': 13}
for item in iter_dict.items():
    print(item, end=' ')




 #Наконец, мы можем перебрать значения словаря, пользуясь классным методом .values():
ln_dict_iter = {'b': 'ln(1)', 'd': 'ln(10)', 'e': 'ln(2)', 'c': 'ln(95)', 'a': 'ln(13)'}
for v in ln_dict_iter.values():
    print(v)




#Объединение словарей
#Когда заходит речь об объединении двух словарей, то обязательно следует упомянуть,
 #что для пары сущностей типа "словарь" оператор "+"не определен.
  #Причина этого становится довольно очевидной — стоит лишь вспомнить,
 #что словарь не является последовательностью, а также задуматься над тем,
 # какая именно операция на множестве словарей должна быть реализована этим самым оператором "+".
 #Поэтому как-то так:

dict_1 = {'010120': 55000, '030420': 8500, '170420': 30000}
dict_2 = {'050520': 2900, '160520': 16573}

#print(dict_1 + dict_2)#Будет ошибка!!!!

#Ну а если вы всё-таки хотите добиться результата и всё же выполнить объединение двух словарей,
#то достаточно воспользоваться методом .update():
showcase_1 = {'Apple': 2.7, 'Grape': 3.5, 'Banana': 4.4}
showcase_2 = {'Orange': 1.9, 'Coconut': 10}
showcase_1.update(showcase_2)
print(showcase_1)


#Ограничения
#оздавая словарь, вы не должны забывать о некоторых ограничениях, накладываемых, в основном, на его ключи.

#анные, представляющие собой ключ словаря, должны быть уникальны внутри множества ключей этого словаря.
#Проще говоря, не должно быть двух одинаковых ключей;
#Ключ должен быть объектом неизменяемого типа, то есть строкой, числом или кортежем.
#Если говорить строже, то объект содержащий ключ должен быть hashable. То есть иметь хеш-значение, которое не меняется в течение его жизненного цикла;
#На значения нет никаких ограничений. Максимальный уровень свободы. 
#Они не обязаны быть ни уникальными, ни неизменяемыми, поэтому могут себе позволить быть какими угодно.



#Методы словарей в Python
#Перечислим основные словарные методы, которые помогут вам при работе с этим типом данных.

#clear() — очищает заданный словарь, приводя его к пустому.
#get() — отдаёт значение словаря по указанному ключу. Если ключ не существует,
#а в качестве дополнительного аргумента передано значение по умолчанию, то метод вернет его. Если же значение по умолчанию опущено, метод вернет None.
#items() — возвращает словарные пары ключ:значение, как соответствующие им кортежи.
#keys() — возвращает ключи словаря, организованные в виде списка.
#values() — подобным образом, возвращает список значений словаря.
#pop() — удалит запись словаря по ключу и вернет её значение.
#popitem() — выбрасывает пару ключ:значение из словаря и возвращает её в качестве кортежа. Такие пары возвращаются в порядке LIFO.
#update() — реализует своеобразную операцию конкатенации для словарей. Он объединяет ключи и значения одного словаря с ключами и значениями другого. При этом если какие-то ключи совпадут, то результирующим значением станет значение словаря, указанного в качестве аргумента метода update.
#copy() — создает полную копию исходного словаря.

# clear()
farewell_dict = {'a': 'word', 'b': 3, 'c': 'x', 'd': 1, 'e': 12}
farewell_dict.clear()
print(farewell_dict)






#Приведение Python-словарей к другим типам
#dict to json
#Чтобы сериализовать словарь в json формат, сперва необходимо импортировать сам модуль json:
import json
#dict to json
#Чтобы сериализовать словарь в json формат, сперва необходимо импортировать сам модуль json:
#dump() позволит вам конвертировать питоновские словари в json объекты и сохранять их в файлы на вашем компьютере. 
#Это несколько напоминает работу с csv.
#dumps() запишет словарь в строку Python, но согласно json-формату.

phonebook = dict(j_row='John Connor', s_row='Sarah Connor')
phonebook_json = json.dumps(phonebook)
print(phonebook_json)


print(type(phonebook_json))






#dict to list
#Для конвертации dict в list достаточно проитерировать словарь попарно с помощью метода items(),
 #и, на каждой итерации, добавлять пару ключ:значение к заранее созданному списку.
  #На выходе получим список списков,
 #где каждый подсписок есть пара из исходного словаря.

medicine_chest = dict(top_part='potion', bot_part='bandage')
medicine_list = []
for key, con in medicine_chest.items():
    temp = [key, con]
    medicine_list.append(temp)
print(medicine_list)


#dict to string
#Как указывалось выше, привести словарь к строке (str) можно при помощи модуля json. 
#Но, если словарь не слишком большой, 
#то эквивалентного результата можно добиться, используя стандартную функцию str():
food_machine = dict(tier_1='juice', tier_2='chocolate')
f_machine_str = str(food_machine)
print(f_machine_str)



#Генератор словарей
#В Python существует возможность создавать словари с помощью генераторов. Генераторы выполняют цикл, 
#отбирают key:value пары на каждой итерации и заполняют, таким образом, новый словарь.
#Создадим словарь, где нескольким элементам ряда натуральных чисел приводятся в соответствие их квадраты:

generated_dict_of_squares = {x: x ** 2 for x in [1, 2, 3, 4]}
print(generated_dict_of_squares)


#Также генератор удобен, когда нужно инициализировать какой-то имеющийся список ключей:
list_of_keys = ['q', 'w', 'e', 'r', 't']
generated_dict = {k: 0 for k in list_of_keys}
print(generated_dict)





#Вложенные словари
#Отдельного упоминания заслуживает тот факт,
#что элемент словаря может принимать в качестве значения другой словарь:
nesting_d = {'fk': {'input_lvl_one': {'input_lvl_two': 42}}}
print(nesting_d['fk']['input_lvl_one']['input_lvl_two'])
#Число уровней вложенности словарей неограниченно!
